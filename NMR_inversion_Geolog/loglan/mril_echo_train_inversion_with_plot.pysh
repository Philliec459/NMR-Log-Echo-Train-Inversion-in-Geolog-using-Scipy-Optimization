#!/usr/bin/env python3
# python loglan
# When referencing Geolog variables in a Python script, names must always be lower case.

# Imports
import geolog
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

from scipy.optimize import minimize

#%matplotlib tk


# Load data from geolog
while geolog.gettable():


    # Put your code here !!!


    df = pd.DataFrame({'depth':depth,'mbvi_in':mbvi_in,'mphi_in':mphi_in, 'p1':p1, 'p2':p2,'p3':p3, 'p4':p4,'p5':p5, 'p6':p6,'p7':p7, 'p8':p8 })



    def func(x,p1,p2,p3,p4,p5,p6,p7,p8):
        return (p1*np.exp(-x/4)+p2*np.exp(-x/8)+p3*np.exp(-x/16)+p4*np.exp(-x/32)+p5*np.exp(-x/64)+p6*np.exp(-x/128)+p7*np.exp(-x/256)+p8*np.exp(-x/512))


    def obj_func(params, x, y, lambda_):
        p1, p2, p3, p4, p5, p6, p7, p8 = params
        residuals = y - func(x, p1, p2, p3, p4, p5, p6, p7, p8)
        regularization = lambda_ * (p1**2 + p2**2 + p3**2 + p4**2 + p5**2 + p6**2 + p7**2 + p8**2)
        return np.sum(residuals**2) + regularization
    
    
        
    deptharray=[]
    mphi = []    
    mbvi = []
    mffi = []    
    echo  = []
    ystack= []
    T21   = []
    T22   = []
    optbins = []
    depth3 = []
    mperm = []


    # Load log data from df
    for index, row in df.iterrows():

    #for k in range(0,len(df) ,1):
        depth2=depth[index]      
        P0=0
        P1=p1[index]
        P2=p2[index]
        P3=p3[index]
        P4=p4[index]
        P5=p5[index]
        P6=p6[index]
        P7=p7[index]
        P8=p8[index]
        P9=0
    
        #depth=depth
        bins=[P0,P1,P2,P3,P4,P5,P6,P7,P8,P9]


        #Define the data to be fit with some noise:
        '''
          This is the xdata for TE x number of echoes for 240ms of echo train data
        '''
        xdata = np.linspace(0, 240, 201)


        '''
          Calculate Echo Train data using xdata and func for echo train equation
        '''
        y = func(xdata,P1, P2, P3,  P4, P5, P6,  P7,  P8)
        #np.random.seed(1729)


        '''
          add noise to the echo train data to create a typical echo train
        '''
        y_noise  = noise * np.random.normal(size=xdata.size)
        ydata = y + y_noise


        '''
          Store Echo Trains in np array
        '''
        echo.append(ydata)
        #yecho = pd.DataFrame(echo)  
        #yecho = echo

        ''' This is stacking of echo trains for better S/N'''
        if index > stack_levels -1:

            if stack_levels == 1:           
                ystack = ydata
            else:
                for k in range(1,stack_levels): 

                    if stack_levels == 2:
                        ystack = (echo[index-1]+echo[index])/stack_levels                 
                    elif stack_levels == 3:
                        ystack = (echo[index-2]+echo[index-1]+echo[index])/stack_levels
                    elif stack_levels ==4:
                        ystack = (echo[index-3]+echo[index-2]+echo[index-1]+echo[index])/stack_levels
                    elif stack_levels == 5:
                        ystack = (echo[index-4]+echo[index-3]+echo[index-2]+echo[index-1]+echo[index])/stack_levels
                    elif stack_levels == 6:
                        ystack = (echo[index-5]+echo[index-4]+echo[index-3]+echo[index-2]+echo[index-1]+echo[index])/stack_levels    
                    elif stack_levels == 7:
                        ystack = (echo[index-6]+echo[index-5]+echo[index-4]+echo[index-3]+echo[index-2]+echo[index-1]+echo[index])/stack_levels    
                    elif stack_levels == 8:
                        ystack = (echo[index-7]+echo[index-6]+echo[index-5]+echo[index-4]+echo[index-3]+echo[index-2]+echo[index-1]+echo[index])/stack_levels    
                    elif stack_levels == 9:
                        ystack = (echo[index-8]+echo[index-7]+echo[index-6]+echo[index-5]+echo[index-4]+echo[index-3]+echo[index-2]+echo[index-1]+echo[index])/stack_levels    

                    else:
                        print('Stack Levels out of bounds')
           

            '''
            -----------------------------------------------------------------------------------------------
              Optimization using SciPy with regularization: 
            -----------------------------------------------------------------------------------------------
            '''
            # Fit the function to the data with regularization
            bnds = [(0, 20)]*8
            lambda_ = 1  #started with 0.1
            p0 = np.ones(8)
            result = minimize(obj_func, p0, args=(xdata, ystack, lambda_), method='L-BFGS-B', bounds=bnds)
            popt = result.x

            #print("Inversion Porosities:" , popt)

            '''
            ------------------------------------------------------------------------------------------------
            The parameter lambda_ determines the strength of the regularization. 

            A smaller value of lambda_ will result in a stronger regularization and a simpler solution, 
            while a larger value of lambda_ will result in a weaker regularization and a more complex solution. 

            You can adjust the value of lambda_ to find a good balance between fitting the data and preventing overfitting.
            --------------------------------------------------------------------------------------------------
            '''





            ''' Calculate BVI, MFFI and MPHI '''
            mbvi.append(popt[0]+popt[1]+popt[2]+0.044*popt[3])    
            mphi.append(popt[0]+popt[1]+popt[2]+popt[3]+popt[4]+popt[5]+popt[6]+popt[7])
            mffi.append((1-0.044)*popt[3]+popt[4]+popt[5]+popt[6]+popt[7])
            
            depth3.append(depth2)

            multiplier = (1 - level_spacing)/2
            deptharray.append(depth - (stack_levels-1)/2 + multiplier*(stack_levels-1))
            
            #print('Depth3 =',depth3,'MPHI =',mphi)


            optbins.append([P0,popt[0],popt[1],popt[2],popt[3],popt[4],popt[5],popt[6],popt[7], P9])
            T2       = [    2,  4,      8,      16,     32,     64,     128,     256,   512,   1024]
            bins     = [    P0, P1,     P2,     P3,     P4,     P5,      P6,      P7,    P8,    P9]
            opt      = ([P0,popt[0],popt[1],popt[2],popt[3],popt[4],popt[5],popt[6],popt[7], P9])





            '''
            --------------------------------------------------------------------------------------------------
            Plot Echo Train, T2 Dist and NMR Inversion MPHI and MBVI log data:
            --------------------------------------------------------------------------------------------------
            '''
            for p in range(1):
                p=0

                fig, ax = plt.subplots(1,3,figsize=(15,4))      
                updated_x = xdata
                updated_y = ystack
                updated_yfit = func(xdata, *popt)
                ax[0].plot(updated_x,updated_y    ,c='green',label='Echo Train')
                ax[0].plot(updated_x,updated_yfit ,c='red',linewidth=3, label='Fit')

                ax[0].set_xlim(0,240)
                ax[0].set_ylim(0,35)
                ax[0].set_ylabel('Amplitude (V/V)')
                ax[0].set_xlabel('Time (ms)')
                ax[0].set_title('NMR Echo Train')
                ax[0].legend(loc='upper right')
                ax[0].grid()

                #ax[1].semilogx(T2,bins   ,c='green', linewidth=1, label = 'Original Bin Porosities')
                ax[1].semilogx(T2,opt    ,c='red'  , linewidth=3, label = 'Inversion Bin Porosities')


                #ax[1].semilogx(33,0.0 ,'k*')
                ax[1].set_xlim(2,1024)
                ax[1].set_ylim(0,20)
                ax[1].set_ylabel('Bin Porosity (V/V)')
                ax[1].set_xlabel('T2 (ms)')
                ax[1].set_title('Echo Train Inversion for T2 Distribution')
                ax[1].axvspan(2,33   ,alpha=0.2,color='blue',label='BVI')
                ax[1].axvspan(33,1024,alpha=0.5,color='yellow',label='FFI')
                ax[1].legend()
                ax[1].grid()

                #ax[2].plot(mphi_in,depth ,alpha=0.4, c='red')
                #ax[2].plot(mbvi_in,depth ,alpha=0.4, c='blue',linewidth=2)
                ax[2].plot(mphi,depth3 ,c='red',linewidth=1)
                ax[2].plot(mbvi,depth3 ,c='blue',linewidth=1)
                
                ax[2].set_xlim(50,0)
                ax[2].set_ylim(max(depth),min(depth))
                ax[2].set_ylabel('Depth)')
                ax[2].set_xlabel('Porosity')
                ax[2].set_title('NMR Log using 33ms T2 Cutoff')
                ax[2].fill_betweenx(depth3, mphi, 0,  color='yellow', alpha=0.6, label='FFI')   
                ax[2].fill_betweenx(depth3, mbvi, 0,  color='blue'  , alpha=0.6, label='BVI')    
                ax[2].legend(loc='upper left')
                ax[2].grid()

                plt.draw()  
                updated_x = xdata
                updated_y = ystack
                updated_yfit = func(xdata, *popt)
                plt.pause(0.01)
                #fig.clear()
                plt.close(fig)
                #fig.clf()





    # Store data into geolog
    geolog.puttable()




